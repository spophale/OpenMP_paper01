The effects of affinity is a widely studied problem. Most programming models take advantage of the architecture and data-access patterns by providing some implicit or explicit control over data and process/thread placement. For example, OpenMP provides implicit data affinity control through policies like \textit{first-touch} and \textit{next-touch}. First-touch is more appropriate for applications where the first access to data is representative of the application\'s data accesses throughout the life of the application. This policy has been adopted as default on many systems. For applications that have a more dynamic access pattern, the \textit{next-touch} policy may be more appropriate. Here the data is marked to be placed closest to the next thread that accesses it. The new OpenMP 4.5 release provides a substantial improvement on the support for programming of accelerator and GPU devices. Amongst the new features introduced are, support for parallelization of loops with well-structured dependencies, mechanisms for unstructured data mapping and asynchronous execution, support to divide loops into tasks without requiring all threads to execute the loop, reductions for C\/C++ arrays, a new hint mechanisms to provide guidance on the relative priority of tasks and on preferred synchronization implementations, SIMD extensions, improved support for Fortran 2003, and
thread affinity support through runtime functions to determine the effect of thread affinity clauses. In this paper we focus on the affinity aspect of OpenMP with respect to the emerging OpenPOWER systems.
